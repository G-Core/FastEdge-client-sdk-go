// Package sdk provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package sdk

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

// Defines values for AppLog.
const (
	AppLogKafka AppLog = "kafka"
	AppLogNone  AppLog = "none"
)

// Defines values for BinaryParamDataType.
const (
	Date   BinaryParamDataType = "date"
	Number BinaryParamDataType = "number"
	String BinaryParamDataType = "string"
	Time   BinaryParamDataType = "time"
)

// Defines values for UpdateAppJSONBodyLog.
const (
	UpdateAppJSONBodyLogKafka UpdateAppJSONBodyLog = "kafka"
	UpdateAppJSONBodyLogNone  UpdateAppJSONBodyLog = "none"
)

// Defines values for ListLogsParamsSort.
const (
	Asc  ListLogsParamsSort = "asc"
	Desc ListLogsParamsSort = "desc"
)

// App defines model for app.
type App struct {
	// Binary Binary ID
	Binary *int64 `json:"binary,omitempty"`

	// Comment Description of the binary
	Comment *string `json:"comment,omitempty"`

	// Debug Switch on logging for 30 minutes (switched off by default)
	Debug *bool `json:"debug,omitempty"`

	// DebugUntil When debugging finishes
	DebugUntil *time.Time `json:"debug_until,omitempty"`

	// Env Environment variables
	Env *map[string]string `json:"env,omitempty"`

	// Log Logging channel (by default - kafka, which allows exploring logs with API)
	Log *AppLog `json:"log"`

	// Name App name
	Name *string `json:"name,omitempty"`

	// Plan Plan name
	Plan *string `json:"plan,omitempty"`

	// RspHeaders Extra headers to add to the response
	RspHeaders *map[string]string `json:"rsp_headers,omitempty"`

	// Status Status code:<br>0 - draft (inactive)<br>1 - enabled<br>2 - disabled<br>3 - hourly call limit exceeded<br>4 - daily call limit exceeded<br>5 - suspended
	Status *int `json:"status,omitempty"`

	// Url App URL
	Url *string `json:"url,omitempty"`
}

// AppLog Logging channel (by default - kafka, which allows exploring logs with API)
type AppLog string

// AppShort defines model for app_short.
type AppShort struct {
	// Binary Binary ID
	Binary int64 `json:"binary"`

	// Comment Description of the binary
	Comment *string `json:"comment,omitempty"`

	// Id App ID
	Id int64 `json:"id"`

	// Name App name
	Name string `json:"name"`

	// Status Status code:<br>0 - draft (inactive)<br>1 - enabled<br>2 - disabled<br>3 - hourly call limit exceeded<br>4 - daily call limit exceeded<br>5 - suspended
	Status int `json:"status"`

	// Url App URL
	Url string `json:"url"`
}

// Binary defines model for binary.
type Binary struct {
	// Descr Short description of the template
	Descr *string `json:"descr,omitempty"`

	// Errors Compilation errors
	Errors *string `json:"errors,omitempty"`

	// GroupId ID of the group binary is shared to
	GroupId int64 `json:"group_id"`

	// Id Binary ID
	Id int64 `json:"id"`

	// Name Name of the template
	Name *string `json:"name,omitempty"`

	// Source Source language:<br>0 - unknown<br>1 - Rust<br>2 - JavaScript
	Source int `json:"source"`

	// Status Status code:<br>0 - pending<br>1 - compiled<br>2 - compilation failed (errors available)<br>3 - compilation failed (errors not available)<br>4 - resulting binary exceeded the limit<br>5 - unsupported source language
	Status int `json:"status"`

	// UnrefSince Not used since (UTC)
	UnrefSince *string `json:"unref_since,omitempty"`
}

// BinaryMetadata defines model for binary_metadata.
type BinaryMetadata struct {
	// Descr Short description of the template
	Descr *string `json:"descr,omitempty"`

	// GroupId The group binary shared to (0 - not shared)
	GroupId int64 `json:"group_id"`

	// LongDescr Long description of the template
	LongDescr *string `json:"long_descr,omitempty"`

	// Name Name of the template
	Name string `json:"name"`

	// Params Parameters
	Params []BinaryParam `json:"params"`
}

// BinaryParam defines model for binary_param.
type BinaryParam struct {
	// DataType Parameter type
	DataType BinaryParamDataType `json:"data_type"`

	// Descr Parameter description
	Descr *string `json:"descr,omitempty"`

	// Mandatory Is this field mandatory?
	Mandatory bool `json:"mandatory"`

	// Name Parameter name
	Name string `json:"name"`
}

// BinaryParamDataType Parameter type
type BinaryParamDataType string

// BinaryShort defines model for binary_short.
type BinaryShort struct {
	// Descr Short description of the template
	Descr *string `json:"descr,omitempty"`

	// GroupId ID of the group binary is shared to
	GroupId int64 `json:"group_id"`

	// Id Binary ID
	Id int64 `json:"id"`

	// Name Name of the template
	Name *string `json:"name,omitempty"`

	// Status Status code:<br>0 - pending<br>1 - compiled<br>2 - compilation failed (errors available)<br>3 - compilation failed (errors not available)<br>4 - resulting binary exceeded the limit<br>5 - unsupported source language
	Status int `json:"status"`

	// UnrefSince Not used since (UTC)
	UnrefSince *string `json:"unref_since,omitempty"`
}

// CallStats Edge app call statistics
type CallStats struct {
	// CountByStatus Count by status
	CountByStatus []CountByStatus `json:"count_by_status"`

	// Time Beginning ot reporting slot
	Time time.Time `json:"time"`
}

// Client defines model for client.
type Client struct {
	// AppCount Actual allowed number of apps
	AppCount int `json:"app_count"`

	// AppLimit Max allowed number of apps
	AppLimit int `json:"app_limit"`

	// DailyConsumption Actual number of calls for all apps during the current day (UTC)
	DailyConsumption int `json:"daily_consumption"`

	// DailyLimit Max allowed calls for all apps during a day (UTC)
	DailyLimit int `json:"daily_limit"`

	// HourlyConsumption Actual number of calls for all apps during the current hour
	HourlyConsumption int `json:"hourly_consumption"`

	// HourlyLimit Max allowed calls for all apps during an hour
	HourlyLimit int `json:"hourly_limit"`

	// Status Status code:<br>1 - enabled<br>2 - disabled<br>3 - hourly call limit exceeded<br>4 - daily call limit exceeded<br>5 - suspended
	Status int `json:"status"`
}

// CountByStatus defines model for count_by_status.
type CountByStatus struct {
	// Count Number of app calls
	Count int `json:"count"`

	// Status HTTP status
	Status int `json:"status"`
}

// DurationStats Edge app execution duration statistics
type DurationStats struct {
	// Avg Average duration in usec
	Avg int64 `json:"avg"`

	// Max Max duration in usec
	Max int64 `json:"max"`

	// Median Median (50% percentile) duration in usec
	Median int64 `json:"median"`

	// Min Min duration in usec
	Min int64 `json:"min"`

	// Perc75 75% percentile duration in usec
	Perc75 int64 `json:"perc75"`

	// Perc90 90% percentile duration in usec
	Perc90 int64 `json:"perc90"`

	// Time Beginning ot reporting slot
	Time time.Time `json:"time"`
}

// Error defines model for error.
type Error struct {
	// Error Error message
	Error string `json:"error"`
}

// Group defines model for group.
type Group struct {
	// Capacity Max number of members (0 means unlimited)
	Capacity int `json:"capacity"`

	// Id Group ID
	Id      int64         `json:"id"`
	Members []GroupMember `json:"members"`

	// Name Group name
	Name string `json:"name"`
}

// GroupMember defines model for group_member.
type GroupMember struct {
	// CanShare Can the member share binaries to the group?
	CanShare *bool `json:"can_share,omitempty"`

	// ClientId Client ID
	ClientId int64 `json:"client_id"`

	// Name Member name
	Name *string `json:"name,omitempty"`
}

// GroupShort defines model for group_short.
type GroupShort struct {
	// Id Group ID
	Id int64 `json:"id"`

	// MemberOf Am I a member of the group?
	MemberOf bool `json:"member_of"`

	// Name Group name
	Name string `json:"name"`
}

// Log defines model for log.
type Log struct {
	// AppName Name of the application
	AppName *string `json:"app_name,omitempty"`

	// ClientIp Client IP
	ClientIp *string `json:"client_ip,omitempty"`

	// Edge Edge name
	Edge *string `json:"edge,omitempty"`

	// Id Id of the log
	Id *string `json:"id,omitempty"`

	// Log Log message
	Log *string `json:"log,omitempty"`

	// Timestamp Timestamp of a log in RFC3339 format
	Timestamp *time.Time `json:"timestamp,omitempty"`
}

// ListAppsParams defines parameters for ListApps.
type ListAppsParams struct {
	// Name Name of the app
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// UpdateAppJSONBody defines parameters for UpdateApp.
type UpdateAppJSONBody struct {
	// Binary Binary ID
	Binary int64 `json:"binary"`

	// Comment Description of the binary
	Comment *string `json:"comment,omitempty"`

	// Debug Switch on logging for 30 minutes (switched off by default)
	Debug *bool `json:"debug,omitempty"`

	// DebugUntil When debugging finishes
	DebugUntil *time.Time `json:"debug_until,omitempty"`

	// Env Environment variables
	Env *map[string]string `json:"env,omitempty"`

	// Log Logging channel (by default - kafka, which allows exploring logs with API)
	Log *UpdateAppJSONBodyLog `json:"log"`

	// Name App name
	Name *string `json:"name,omitempty"`

	// Plan Plan name
	Plan *string `json:"plan,omitempty"`

	// RspHeaders Extra headers to add to the response
	RspHeaders *map[string]string `json:"rsp_headers,omitempty"`

	// Status Status code:<br>0 - draft (inactive)<br>1 - enabled<br>2 - disabled<br>3 - hourly call limit exceeded<br>4 - daily call limit exceeded<br>5 - suspended
	Status int `json:"status"`

	// Url App URL
	Url *string `json:"url,omitempty"`
}

// UpdateAppJSONBodyLog defines parameters for UpdateApp.
type UpdateAppJSONBodyLog string

// ListLogsParams defines parameters for ListLogs.
type ListLogsParams struct {
	// From Reporting period start time, RFC3339 format. Default 1 hour ago.
	From *time.Time `form:"from,omitempty" json:"from,omitempty"`

	// To Reporting period end time, RFC3339 format. Default current time in UTC.
	To *time.Time `form:"to,omitempty" json:"to,omitempty"`

	// Edge Edge name
	Edge *string `form:"edge,omitempty" json:"edge,omitempty"`

	// Sort Sort order (default desc)
	Sort *ListLogsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Limit Limit for pagination
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Offset for pagination
	Offset *int32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Search Search string
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// ClientIp Search by client IP
	ClientIp *string `form:"client_ip,omitempty" json:"client_ip,omitempty"`
}

// ListLogsParamsSort defines parameters for ListLogs.
type ListLogsParamsSort string

// ListBinariesParams defines parameters for ListBinaries.
type ListBinariesParams struct {
	// Shared Templates shared with me
	Shared *bool `form:"shared,omitempty" json:"shared,omitempty"`

	// Named Binaries with non-empty name
	Named *bool `form:"named,omitempty" json:"named,omitempty"`
}

// ListGroupsParams defines parameters for ListGroups.
type ListGroupsParams struct {
	// MemberOf Am I a member of the group?
	MemberOf *bool `form:"member_of,omitempty" json:"member_of,omitempty"`
}

// AddGroupJSONBody defines parameters for AddGroup.
type AddGroupJSONBody struct {
	// Name Group name
	Name string `json:"name"`
}

// DelGroupParams defines parameters for DelGroup.
type DelGroupParams struct {
	// Force Delete even if group is non-empty
	Force *bool `form:"force,omitempty" json:"force,omitempty"`
}

// UpdateGroupJSONBody defines parameters for UpdateGroup.
type UpdateGroupJSONBody struct {
	// Name Group name
	Name string `json:"name"`
}

// StatsDurationParams defines parameters for StatsDuration.
type StatsDurationParams struct {
	// Id App ID
	Id *int64 `form:"id,omitempty" json:"id,omitempty"`

	// From Reporting period start time, RFC3339 format
	From time.Time `form:"from" json:"from"`

	// To Reporting period end time (not included into reporting period), RFC3339 format
	To time.Time `form:"to" json:"to"`

	// Step Reporting granularity, in seconds
	Step int `form:"step" json:"step"`
}

// StatsCallsParams defines parameters for StatsCalls.
type StatsCallsParams struct {
	// From Reporting period start time, RFC3339 format
	From time.Time `form:"from" json:"from"`

	// To Reporting period end time (not included into reporting period), RFC3339 format
	To time.Time `form:"to" json:"to"`

	// Step Reporting granularity, in seconds
	Step int `form:"step" json:"step"`

	// Id App ID
	Id *int64 `form:"id,omitempty" json:"id,omitempty"`
}

// AddAppJSONRequestBody defines body for AddApp for application/json ContentType.
type AddAppJSONRequestBody = App

// PatchAppJSONRequestBody defines body for PatchApp for application/json ContentType.
type PatchAppJSONRequestBody = App

// UpdateAppJSONRequestBody defines body for UpdateApp for application/json ContentType.
type UpdateAppJSONRequestBody UpdateAppJSONBody

// UpdateBinaryMetadataJSONRequestBody defines body for UpdateBinaryMetadata for application/json ContentType.
type UpdateBinaryMetadataJSONRequestBody = BinaryMetadata

// AddGroupJSONRequestBody defines body for AddGroup for application/json ContentType.
type AddGroupJSONRequestBody AddGroupJSONBody

// UpdateGroupJSONRequestBody defines body for UpdateGroup for application/json ContentType.
type UpdateGroupJSONRequestBody UpdateGroupJSONBody

// AddToGroupJSONRequestBody defines body for AddToGroup for application/json ContentType.
type AddToGroupJSONRequestBody = GroupMember

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// ClientSDK which conforms to the OpenAPI3 specification for this service.
type ClientSDK struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*ClientSDK) error

// Creates a new ClientSDK, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*ClientSDK, error) {
	// create a client with sane default values
	client := ClientSDK{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *ClientSDK) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *ClientSDK) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListApps request
	ListApps(ctx context.Context, params *ListAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddAppWithBody request with any body
	AddAppWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddApp(ctx context.Context, body AddAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppIdByName request
	GetAppIdByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DelApp request
	DelApp(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApp request
	GetApp(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchAppWithBody request with any body
	PatchAppWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApp(ctx context.Context, id int64, body PatchAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAppWithBody request with any body
	UpdateAppWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateApp(ctx context.Context, id int64, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLogs request
	ListLogs(ctx context.Context, id int64, params *ListLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBinaries request
	ListBinaries(ctx context.Context, params *ListBinariesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreBinaryWithBody request with any body
	StoreBinaryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DelBinary request
	DelBinary(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBinary request
	GetBinary(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBinaryMetadata request
	GetBinaryMetadata(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBinaryMetadataWithBody request with any body
	UpdateBinaryMetadataWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBinaryMetadata(ctx context.Context, id int64, body UpdateBinaryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGroups request
	ListGroups(ctx context.Context, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddGroupWithBody request with any body
	AddGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddGroup(ctx context.Context, body AddGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DelGroup request
	DelGroup(ctx context.Context, id int64, params *DelGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroup request
	GetGroup(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGroupWithBody request with any body
	UpdateGroupWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateGroup(ctx context.Context, id int64, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LeaveGroup request
	LeaveGroup(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddToGroupWithBody request with any body
	AddToGroupWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddToGroup(ctx context.Context, id int64, body AddToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DelFromGroup request
	DelFromGroup(ctx context.Context, id int64, clientId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClientMe request
	GetClientMe(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StatsDuration request
	StatsDuration(ctx context.Context, params *StatsDurationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StatsCalls request
	StatsCalls(ctx context.Context, params *StatsCallsParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *ClientSDK) ListApps(ctx context.Context, params *ListAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAppsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) AddAppWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddAppRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) AddApp(ctx context.Context, body AddAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddAppRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) GetAppIdByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppIdByNameRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) DelApp(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDelAppRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) GetApp(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) PatchAppWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchAppRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) PatchApp(ctx context.Context, id int64, body PatchAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchAppRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) UpdateAppWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) UpdateApp(ctx context.Context, id int64, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) ListLogs(ctx context.Context, id int64, params *ListLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLogsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) ListBinaries(ctx context.Context, params *ListBinariesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBinariesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) StoreBinaryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreBinaryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) DelBinary(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDelBinaryRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) GetBinary(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBinaryRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) GetBinaryMetadata(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBinaryMetadataRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) UpdateBinaryMetadataWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBinaryMetadataRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) UpdateBinaryMetadata(ctx context.Context, id int64, body UpdateBinaryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBinaryMetadataRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) ListGroups(ctx context.Context, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) AddGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddGroupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) AddGroup(ctx context.Context, body AddGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddGroupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) DelGroup(ctx context.Context, id int64, params *DelGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDelGroupRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) GetGroup(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) UpdateGroupWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGroupRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) UpdateGroup(ctx context.Context, id int64, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGroupRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) LeaveGroup(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLeaveGroupRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) AddToGroupWithBody(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddToGroupRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) AddToGroup(ctx context.Context, id int64, body AddToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddToGroupRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) DelFromGroup(ctx context.Context, id int64, clientId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDelFromGroupRequest(c.Server, id, clientId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) GetClientMe(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClientMeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) StatsDuration(ctx context.Context, params *StatsDurationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatsDurationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *ClientSDK) StatsCalls(ctx context.Context, params *StatsCallsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatsCallsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListAppsRequest generates requests for ListApps
func NewListAppsRequest(server string, params *ListAppsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/apps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddAppRequest calls the generic AddApp builder with application/json body
func NewAddAppRequest(server string, body AddAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddAppRequestWithBody(server, "application/json", bodyReader)
}

// NewAddAppRequestWithBody generates requests for AddApp with any type of body
func NewAddAppRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/apps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAppIdByNameRequest generates requests for GetAppIdByName
func NewGetAppIdByNameRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/apps/by-name/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDelAppRequest generates requests for DelApp
func NewDelAppRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppRequest generates requests for GetApp
func NewGetAppRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchAppRequest calls the generic PatchApp builder with application/json body
func NewPatchAppRequest(server string, id int64, body PatchAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchAppRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPatchAppRequestWithBody generates requests for PatchApp with any type of body
func NewPatchAppRequestWithBody(server string, id int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateAppRequest calls the generic UpdateApp builder with application/json body
func NewUpdateAppRequest(server string, id int64, body UpdateAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAppRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateAppRequestWithBody generates requests for UpdateApp with any type of body
func NewUpdateAppRequestWithBody(server string, id int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListLogsRequest generates requests for ListLogs
func NewListLogsRequest(server string, id int64, params *ListLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/apps/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Edge != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "edge", runtime.ParamLocationQuery, *params.Edge); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClientIp != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_ip", runtime.ParamLocationQuery, *params.ClientIp); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBinariesRequest generates requests for ListBinaries
func NewListBinariesRequest(server string, params *ListBinariesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/binaries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Shared != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "shared", runtime.ParamLocationQuery, *params.Shared); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Named != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "named", runtime.ParamLocationQuery, *params.Named); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStoreBinaryRequestWithBody generates requests for StoreBinary with any type of body
func NewStoreBinaryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/binaries/raw")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDelBinaryRequest generates requests for DelBinary
func NewDelBinaryRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/binaries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBinaryRequest generates requests for GetBinary
func NewGetBinaryRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/binaries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBinaryMetadataRequest generates requests for GetBinaryMetadata
func NewGetBinaryMetadataRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/binaries/%s/metadata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateBinaryMetadataRequest calls the generic UpdateBinaryMetadata builder with application/json body
func NewUpdateBinaryMetadataRequest(server string, id int64, body UpdateBinaryMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBinaryMetadataRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateBinaryMetadataRequestWithBody generates requests for UpdateBinaryMetadata with any type of body
func NewUpdateBinaryMetadataRequestWithBody(server string, id int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/binaries/%s/metadata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListGroupsRequest generates requests for ListGroups
func NewListGroupsRequest(server string, params *ListGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MemberOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "member_of", runtime.ParamLocationQuery, *params.MemberOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddGroupRequest calls the generic AddGroup builder with application/json body
func NewAddGroupRequest(server string, body AddGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddGroupRequestWithBody(server, "application/json", bodyReader)
}

// NewAddGroupRequestWithBody generates requests for AddGroup with any type of body
func NewAddGroupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDelGroupRequest generates requests for DelGroup
func NewDelGroupRequest(server string, id int64, params *DelGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupRequest generates requests for GetGroup
func NewGetGroupRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateGroupRequest calls the generic UpdateGroup builder with application/json body
func NewUpdateGroupRequest(server string, id int64, body UpdateGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateGroupRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateGroupRequestWithBody generates requests for UpdateGroup with any type of body
func NewUpdateGroupRequestWithBody(server string, id int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLeaveGroupRequest generates requests for LeaveGroup
func NewLeaveGroupRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/groups/%s/member", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddToGroupRequest calls the generic AddToGroup builder with application/json body
func NewAddToGroupRequest(server string, id int64, body AddToGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddToGroupRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAddToGroupRequestWithBody generates requests for AddToGroup with any type of body
func NewAddToGroupRequestWithBody(server string, id int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/groups/%s/member", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDelFromGroupRequest generates requests for DelFromGroup
func NewDelFromGroupRequest(server string, id int64, clientId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/groups/%s/member/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClientMeRequest generates requests for GetClientMe
func NewGetClientMeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStatsDurationRequest generates requests for StatsDuration
func NewStatsDurationRequest(server string, params *StatsDurationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/stats/app_duration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "step", runtime.ParamLocationQuery, params.Step); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStatsCallsRequest generates requests for StatsCalls
func NewStatsCallsRequest(server string, params *StatsCallsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/stats/calls")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "step", runtime.ParamLocationQuery, params.Step); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *ClientSDK) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *ClientSDK) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListAppsWithResponse request
	ListAppsWithResponse(ctx context.Context, params *ListAppsParams, reqEditors ...RequestEditorFn) (*ListAppsResponse, error)

	// AddAppWithBodyWithResponse request with any body
	AddAppWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddAppResponse, error)

	AddAppWithResponse(ctx context.Context, body AddAppJSONRequestBody, reqEditors ...RequestEditorFn) (*AddAppResponse, error)

	// GetAppIdByNameWithResponse request
	GetAppIdByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetAppIdByNameResponse, error)

	// DelAppWithResponse request
	DelAppWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*DelAppResponse, error)

	// GetAppWithResponse request
	GetAppWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetAppResponse, error)

	// PatchAppWithBodyWithResponse request with any body
	PatchAppWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchAppResponse, error)

	PatchAppWithResponse(ctx context.Context, id int64, body PatchAppJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchAppResponse, error)

	// UpdateAppWithBodyWithResponse request with any body
	UpdateAppWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppResponse, error)

	UpdateAppWithResponse(ctx context.Context, id int64, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppResponse, error)

	// ListLogsWithResponse request
	ListLogsWithResponse(ctx context.Context, id int64, params *ListLogsParams, reqEditors ...RequestEditorFn) (*ListLogsResponse, error)

	// ListBinariesWithResponse request
	ListBinariesWithResponse(ctx context.Context, params *ListBinariesParams, reqEditors ...RequestEditorFn) (*ListBinariesResponse, error)

	// StoreBinaryWithBodyWithResponse request with any body
	StoreBinaryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreBinaryResponse, error)

	// DelBinaryWithResponse request
	DelBinaryWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*DelBinaryResponse, error)

	// GetBinaryWithResponse request
	GetBinaryWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetBinaryResponse, error)

	// GetBinaryMetadataWithResponse request
	GetBinaryMetadataWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetBinaryMetadataResponse, error)

	// UpdateBinaryMetadataWithBodyWithResponse request with any body
	UpdateBinaryMetadataWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBinaryMetadataResponse, error)

	UpdateBinaryMetadataWithResponse(ctx context.Context, id int64, body UpdateBinaryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBinaryMetadataResponse, error)

	// ListGroupsWithResponse request
	ListGroupsWithResponse(ctx context.Context, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*ListGroupsResponse, error)

	// AddGroupWithBodyWithResponse request with any body
	AddGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddGroupResponse, error)

	AddGroupWithResponse(ctx context.Context, body AddGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AddGroupResponse, error)

	// DelGroupWithResponse request
	DelGroupWithResponse(ctx context.Context, id int64, params *DelGroupParams, reqEditors ...RequestEditorFn) (*DelGroupResponse, error)

	// GetGroupWithResponse request
	GetGroupWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetGroupResponse, error)

	// UpdateGroupWithBodyWithResponse request with any body
	UpdateGroupWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error)

	UpdateGroupWithResponse(ctx context.Context, id int64, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error)

	// LeaveGroupWithResponse request
	LeaveGroupWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*LeaveGroupResponse, error)

	// AddToGroupWithBodyWithResponse request with any body
	AddToGroupWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddToGroupResponse, error)

	AddToGroupWithResponse(ctx context.Context, id int64, body AddToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AddToGroupResponse, error)

	// DelFromGroupWithResponse request
	DelFromGroupWithResponse(ctx context.Context, id int64, clientId int64, reqEditors ...RequestEditorFn) (*DelFromGroupResponse, error)

	// GetClientMeWithResponse request
	GetClientMeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClientMeResponse, error)

	// StatsDurationWithResponse request
	StatsDurationWithResponse(ctx context.Context, params *StatsDurationParams, reqEditors ...RequestEditorFn) (*StatsDurationResponse, error)

	// StatsCallsWithResponse request
	StatsCallsWithResponse(ctx context.Context, params *StatsCallsParams, reqEditors ...RequestEditorFn) (*StatsCallsResponse, error)
}

type ListAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Apps []AppShort `json:"apps"`
	}
}

// Status returns HTTPResponse.Status
func (r ListAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppShort
	JSON400      *Error
	JSON429      *Error
	JSON503      *Error
}

// Status returns HTTPResponse.Status
func (r AddAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppIdByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int64
	JSON400      *Error
}

// Status returns HTTPResponse.Status
func (r GetAppIdByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppIdByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DelAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DelAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DelAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *App
	JSON400      *Error
}

// Status returns HTTPResponse.Status
func (r GetAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppShort
}

// Status returns HTTPResponse.Status
func (r PatchAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppShort
	JSON400      *Error
	JSON503      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Logs *[]Log `json:"logs,omitempty"`

		// Offset Current request offset
		Offset *int32 `json:"offset,omitempty"`

		// TotalCount Number of total logs available
		TotalCount *int32 `json:"total_count,omitempty"`
	}
	JSON400 *Error
	JSON503 *Error
}

// Status returns HTTPResponse.Status
func (r ListLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBinariesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Binaries []BinaryShort `json:"binaries"`
	}
}

// Status returns HTTPResponse.Status
func (r ListBinariesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBinariesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreBinaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BinaryShort
	JSON400      *Error
	JSON429      *Error
	JSON503      *Error
}

// Status returns HTTPResponse.Status
func (r StoreBinaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreBinaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DelBinaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON503      *Error
}

// Status returns HTTPResponse.Status
func (r DelBinaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DelBinaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBinaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Binary
	JSON400      *Error
}

// Status returns HTTPResponse.Status
func (r GetBinaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBinaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBinaryMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BinaryMetadata
	JSON400      *Error
}

// Status returns HTTPResponse.Status
func (r GetBinaryMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBinaryMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBinaryMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON503      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateBinaryMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBinaryMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Groups []GroupShort `json:"groups"`
	}
}

// Status returns HTTPResponse.Status
func (r ListGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupShort
}

// Status returns HTTPResponse.Status
func (r AddGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DelGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DelGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DelGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Group
	JSON400      *Error
}

// Status returns HTTPResponse.Status
func (r GetGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupShort
}

// Status returns HTTPResponse.Status
func (r UpdateGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LeaveGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
}

// Status returns HTTPResponse.Status
func (r LeaveGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LeaveGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddToGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON429      *Error
}

// Status returns HTTPResponse.Status
func (r AddToGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddToGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DelFromGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
}

// Status returns HTTPResponse.Status
func (r DelFromGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DelFromGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClientMeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Client
	JSON400      *Error
}

// Status returns HTTPResponse.Status
func (r GetClientMeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClientMeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StatsDurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Stats []DurationStats `json:"stats"`
	}
}

// Status returns HTTPResponse.Status
func (r StatsDurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatsDurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StatsCallsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Stats []CallStats `json:"stats"`
	}
}

// Status returns HTTPResponse.Status
func (r StatsCallsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatsCallsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListAppsWithResponse request returning *ListAppsResponse
func (c *ClientWithResponses) ListAppsWithResponse(ctx context.Context, params *ListAppsParams, reqEditors ...RequestEditorFn) (*ListAppsResponse, error) {
	rsp, err := c.ListApps(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAppsResponse(rsp)
}

// AddAppWithBodyWithResponse request with arbitrary body returning *AddAppResponse
func (c *ClientWithResponses) AddAppWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddAppResponse, error) {
	rsp, err := c.AddAppWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddAppResponse(rsp)
}

func (c *ClientWithResponses) AddAppWithResponse(ctx context.Context, body AddAppJSONRequestBody, reqEditors ...RequestEditorFn) (*AddAppResponse, error) {
	rsp, err := c.AddApp(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddAppResponse(rsp)
}

// GetAppIdByNameWithResponse request returning *GetAppIdByNameResponse
func (c *ClientWithResponses) GetAppIdByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetAppIdByNameResponse, error) {
	rsp, err := c.GetAppIdByName(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppIdByNameResponse(rsp)
}

// DelAppWithResponse request returning *DelAppResponse
func (c *ClientWithResponses) DelAppWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*DelAppResponse, error) {
	rsp, err := c.DelApp(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDelAppResponse(rsp)
}

// GetAppWithResponse request returning *GetAppResponse
func (c *ClientWithResponses) GetAppWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetAppResponse, error) {
	rsp, err := c.GetApp(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppResponse(rsp)
}

// PatchAppWithBodyWithResponse request with arbitrary body returning *PatchAppResponse
func (c *ClientWithResponses) PatchAppWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchAppResponse, error) {
	rsp, err := c.PatchAppWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchAppResponse(rsp)
}

func (c *ClientWithResponses) PatchAppWithResponse(ctx context.Context, id int64, body PatchAppJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchAppResponse, error) {
	rsp, err := c.PatchApp(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchAppResponse(rsp)
}

// UpdateAppWithBodyWithResponse request with arbitrary body returning *UpdateAppResponse
func (c *ClientWithResponses) UpdateAppWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppResponse, error) {
	rsp, err := c.UpdateAppWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppResponse(rsp)
}

func (c *ClientWithResponses) UpdateAppWithResponse(ctx context.Context, id int64, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppResponse, error) {
	rsp, err := c.UpdateApp(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppResponse(rsp)
}

// ListLogsWithResponse request returning *ListLogsResponse
func (c *ClientWithResponses) ListLogsWithResponse(ctx context.Context, id int64, params *ListLogsParams, reqEditors ...RequestEditorFn) (*ListLogsResponse, error) {
	rsp, err := c.ListLogs(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLogsResponse(rsp)
}

// ListBinariesWithResponse request returning *ListBinariesResponse
func (c *ClientWithResponses) ListBinariesWithResponse(ctx context.Context, params *ListBinariesParams, reqEditors ...RequestEditorFn) (*ListBinariesResponse, error) {
	rsp, err := c.ListBinaries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBinariesResponse(rsp)
}

// StoreBinaryWithBodyWithResponse request with arbitrary body returning *StoreBinaryResponse
func (c *ClientWithResponses) StoreBinaryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreBinaryResponse, error) {
	rsp, err := c.StoreBinaryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreBinaryResponse(rsp)
}

// DelBinaryWithResponse request returning *DelBinaryResponse
func (c *ClientWithResponses) DelBinaryWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*DelBinaryResponse, error) {
	rsp, err := c.DelBinary(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDelBinaryResponse(rsp)
}

// GetBinaryWithResponse request returning *GetBinaryResponse
func (c *ClientWithResponses) GetBinaryWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetBinaryResponse, error) {
	rsp, err := c.GetBinary(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBinaryResponse(rsp)
}

// GetBinaryMetadataWithResponse request returning *GetBinaryMetadataResponse
func (c *ClientWithResponses) GetBinaryMetadataWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetBinaryMetadataResponse, error) {
	rsp, err := c.GetBinaryMetadata(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBinaryMetadataResponse(rsp)
}

// UpdateBinaryMetadataWithBodyWithResponse request with arbitrary body returning *UpdateBinaryMetadataResponse
func (c *ClientWithResponses) UpdateBinaryMetadataWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBinaryMetadataResponse, error) {
	rsp, err := c.UpdateBinaryMetadataWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBinaryMetadataResponse(rsp)
}

func (c *ClientWithResponses) UpdateBinaryMetadataWithResponse(ctx context.Context, id int64, body UpdateBinaryMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBinaryMetadataResponse, error) {
	rsp, err := c.UpdateBinaryMetadata(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBinaryMetadataResponse(rsp)
}

// ListGroupsWithResponse request returning *ListGroupsResponse
func (c *ClientWithResponses) ListGroupsWithResponse(ctx context.Context, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*ListGroupsResponse, error) {
	rsp, err := c.ListGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupsResponse(rsp)
}

// AddGroupWithBodyWithResponse request with arbitrary body returning *AddGroupResponse
func (c *ClientWithResponses) AddGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddGroupResponse, error) {
	rsp, err := c.AddGroupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddGroupResponse(rsp)
}

func (c *ClientWithResponses) AddGroupWithResponse(ctx context.Context, body AddGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AddGroupResponse, error) {
	rsp, err := c.AddGroup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddGroupResponse(rsp)
}

// DelGroupWithResponse request returning *DelGroupResponse
func (c *ClientWithResponses) DelGroupWithResponse(ctx context.Context, id int64, params *DelGroupParams, reqEditors ...RequestEditorFn) (*DelGroupResponse, error) {
	rsp, err := c.DelGroup(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDelGroupResponse(rsp)
}

// GetGroupWithResponse request returning *GetGroupResponse
func (c *ClientWithResponses) GetGroupWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetGroupResponse, error) {
	rsp, err := c.GetGroup(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupResponse(rsp)
}

// UpdateGroupWithBodyWithResponse request with arbitrary body returning *UpdateGroupResponse
func (c *ClientWithResponses) UpdateGroupWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error) {
	rsp, err := c.UpdateGroupWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGroupResponse(rsp)
}

func (c *ClientWithResponses) UpdateGroupWithResponse(ctx context.Context, id int64, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error) {
	rsp, err := c.UpdateGroup(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGroupResponse(rsp)
}

// LeaveGroupWithResponse request returning *LeaveGroupResponse
func (c *ClientWithResponses) LeaveGroupWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*LeaveGroupResponse, error) {
	rsp, err := c.LeaveGroup(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLeaveGroupResponse(rsp)
}

// AddToGroupWithBodyWithResponse request with arbitrary body returning *AddToGroupResponse
func (c *ClientWithResponses) AddToGroupWithBodyWithResponse(ctx context.Context, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddToGroupResponse, error) {
	rsp, err := c.AddToGroupWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddToGroupResponse(rsp)
}

func (c *ClientWithResponses) AddToGroupWithResponse(ctx context.Context, id int64, body AddToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AddToGroupResponse, error) {
	rsp, err := c.AddToGroup(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddToGroupResponse(rsp)
}

// DelFromGroupWithResponse request returning *DelFromGroupResponse
func (c *ClientWithResponses) DelFromGroupWithResponse(ctx context.Context, id int64, clientId int64, reqEditors ...RequestEditorFn) (*DelFromGroupResponse, error) {
	rsp, err := c.DelFromGroup(ctx, id, clientId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDelFromGroupResponse(rsp)
}

// GetClientMeWithResponse request returning *GetClientMeResponse
func (c *ClientWithResponses) GetClientMeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClientMeResponse, error) {
	rsp, err := c.GetClientMe(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClientMeResponse(rsp)
}

// StatsDurationWithResponse request returning *StatsDurationResponse
func (c *ClientWithResponses) StatsDurationWithResponse(ctx context.Context, params *StatsDurationParams, reqEditors ...RequestEditorFn) (*StatsDurationResponse, error) {
	rsp, err := c.StatsDuration(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatsDurationResponse(rsp)
}

// StatsCallsWithResponse request returning *StatsCallsResponse
func (c *ClientWithResponses) StatsCallsWithResponse(ctx context.Context, params *StatsCallsParams, reqEditors ...RequestEditorFn) (*StatsCallsResponse, error) {
	rsp, err := c.StatsCalls(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatsCallsResponse(rsp)
}

// ParseListAppsResponse parses an HTTP response from a ListAppsWithResponse call
func ParseListAppsResponse(rsp *http.Response) (*ListAppsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Apps []AppShort `json:"apps"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddAppResponse parses an HTTP response from a AddAppWithResponse call
func ParseAddAppResponse(rsp *http.Response) (*AddAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppShort
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetAppIdByNameResponse parses an HTTP response from a GetAppIdByNameWithResponse call
func ParseGetAppIdByNameResponse(rsp *http.Response) (*GetAppIdByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppIdByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int64
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDelAppResponse parses an HTTP response from a DelAppWithResponse call
func ParseDelAppResponse(rsp *http.Response) (*DelAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DelAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAppResponse parses an HTTP response from a GetAppWithResponse call
func ParseGetAppResponse(rsp *http.Response) (*GetAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePatchAppResponse parses an HTTP response from a PatchAppWithResponse call
func ParsePatchAppResponse(rsp *http.Response) (*PatchAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppShort
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateAppResponse parses an HTTP response from a UpdateAppWithResponse call
func ParseUpdateAppResponse(rsp *http.Response) (*UpdateAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppShort
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListLogsResponse parses an HTTP response from a ListLogsWithResponse call
func ParseListLogsResponse(rsp *http.Response) (*ListLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Logs *[]Log `json:"logs,omitempty"`

			// Offset Current request offset
			Offset *int32 `json:"offset,omitempty"`

			// TotalCount Number of total logs available
			TotalCount *int32 `json:"total_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListBinariesResponse parses an HTTP response from a ListBinariesWithResponse call
func ParseListBinariesResponse(rsp *http.Response) (*ListBinariesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBinariesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Binaries []BinaryShort `json:"binaries"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStoreBinaryResponse parses an HTTP response from a StoreBinaryWithResponse call
func ParseStoreBinaryResponse(rsp *http.Response) (*StoreBinaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreBinaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BinaryShort
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDelBinaryResponse parses an HTTP response from a DelBinaryWithResponse call
func ParseDelBinaryResponse(rsp *http.Response) (*DelBinaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DelBinaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetBinaryResponse parses an HTTP response from a GetBinaryWithResponse call
func ParseGetBinaryResponse(rsp *http.Response) (*GetBinaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBinaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Binary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetBinaryMetadataResponse parses an HTTP response from a GetBinaryMetadataWithResponse call
func ParseGetBinaryMetadataResponse(rsp *http.Response) (*GetBinaryMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBinaryMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BinaryMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateBinaryMetadataResponse parses an HTTP response from a UpdateBinaryMetadataWithResponse call
func ParseUpdateBinaryMetadataResponse(rsp *http.Response) (*UpdateBinaryMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateBinaryMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseListGroupsResponse parses an HTTP response from a ListGroupsWithResponse call
func ParseListGroupsResponse(rsp *http.Response) (*ListGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Groups []GroupShort `json:"groups"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddGroupResponse parses an HTTP response from a AddGroupWithResponse call
func ParseAddGroupResponse(rsp *http.Response) (*AddGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupShort
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDelGroupResponse parses an HTTP response from a DelGroupWithResponse call
func ParseDelGroupResponse(rsp *http.Response) (*DelGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DelGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetGroupResponse parses an HTTP response from a GetGroupWithResponse call
func ParseGetGroupResponse(rsp *http.Response) (*GetGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateGroupResponse parses an HTTP response from a UpdateGroupWithResponse call
func ParseUpdateGroupResponse(rsp *http.Response) (*UpdateGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupShort
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLeaveGroupResponse parses an HTTP response from a LeaveGroupWithResponse call
func ParseLeaveGroupResponse(rsp *http.Response) (*LeaveGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LeaveGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseAddToGroupResponse parses an HTTP response from a AddToGroupWithResponse call
func ParseAddToGroupResponse(rsp *http.Response) (*AddToGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddToGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseDelFromGroupResponse parses an HTTP response from a DelFromGroupWithResponse call
func ParseDelFromGroupResponse(rsp *http.Response) (*DelFromGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DelFromGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetClientMeResponse parses an HTTP response from a GetClientMeWithResponse call
func ParseGetClientMeResponse(rsp *http.Response) (*GetClientMeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClientMeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Client
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseStatsDurationResponse parses an HTTP response from a StatsDurationWithResponse call
func ParseStatsDurationResponse(rsp *http.Response) (*StatsDurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StatsDurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Stats []DurationStats `json:"stats"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStatsCallsResponse parses an HTTP response from a StatsCallsWithResponse call
func ParseStatsCallsResponse(rsp *http.Response) (*StatsCallsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StatsCallsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Stats []CallStats `json:"stats"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
